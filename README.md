# FindSport Time Basket Test

В репозитории представлена часть продуктового кода FindSport.ru – маркетплейса и системы управления
спортивным объектами.

Данная часть отвечает за выбор подходящего объекта при бронировании пользователем времени в расписании.

К примеру, есть теннисный клуб с тремя одинаковыми кортами. Каждый корт имеет отдельное расписания (`schedule`), 
Предположим, что у теннисного клуба шаг расписания (`scheduleStep`) – 30 минут, т.е. клиенты могут бронировать 1 час, 1 час 30 минут, 
2 часа, 2 часа 30 минут и т.д. Клиент хочет забронировать два с половиной часа на одном из кортов с 17:00 до 19:30 (`Interval`).
Ему без разницы на каком. Система должна автоматически определить корт, на котором будет заниматься клиент.

## Принципы для определения наиболее подходящего корта
Для этого система руководствуются несколькими принципами:
1. Принцип наименьшей беготни клиента (`SmallestClientBustlePrinciple`) – к примеру, на первом корте занято время с 17:00 до 17:30, 
на втором с 17:30 до 18:00, на третьем всё свободно. Если мы заставим клиента каждые полчаса (или каждый час) бегать между 
несколькими кортами, когда рядом будет пустовать третий корт, то клиент останется недоволен. Поэтому самый главный принцип – 
ищем свободные интервалы, которые можно объединить. То есть пытаемся добавить интервал (`Interval`) целиком, а если не получается, 
то пытаемся это сделать с наименьшим количеством склеек.
2. Принцип отсутствия чёрных дыр (`AvoidingBlackHolesPrinciple`) – данный принцип действует только на площадках, где есть получасовые 
интервалы. Если клиент добавляет время и рядом оказывается свободный один получасовой интервал, то этот получасовой интервал мало кто сможет 
забронировать. Поэтому был придуман принцип отсутствия чёрных дыр, согласно которому мы отсекаем расписания, на которых могут 
образоваться свободные получасовые интервалы по бокам от добавляемого. Если на всех свободных расписаниях есть получасовые дыры, 
то мы выбираем то расписание, на котором их меньше всего (максимум может быть две дыры, минимум одна). Если есть несколько расписаний 
с одинаковыми условиями, на которых мы можем избежать дыр, то переходим к следующему принципу.
3. Принцип добрых соседей (`GoodNeighborsPrinciple`) – если мы находим два и больше свободных расписаний, на которые мы можем добавить 
время (с одинаковым числом склеек), то при выборе расписания мы руководствуемся тем, есть ли занятое время рядом. Этот принцип необходим 
для того, чтобы равномерно занимать расписания, тем самым минимизируя вероятность беготни клиента между объектами. В первую очередь 
мы смотрим расписание, на котором есть граничащее время слева и справа, потом слева, потом справа.

## Задание
В данном задании предлагается написать код для метода `processing()` внутри одного из следующих классов на ваш выбор:
* `app\components\basket\schedule_definition\AvoidingBlackHolesPrinciple`
* `app\components\basket\schedule_definition\GoodNeighborsPrinciple`
* `app\components\basket\schedule_definition\SmallestClientBustlePrinciple` 

Данные классы запускаются из команды `app\components\basket\schedule_definition\ScheduleDefinitionCommand` – их основная задача вернуть 
идентификаторы расписаний, на которые можно добавить интервал.

`Interval` – класс объекта интервала времени в течение одного дня, который клиент бронирует.

`IntervalStep` – класс объекта времени в расписании корта равный шагу расписания. У каждого шага есть статус – занято время или свободно.
 
`IntervalStepRepository` – репозиторий объектов времени всех кортов, который содержит и занятое, и свободное время.

